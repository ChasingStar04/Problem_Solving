/*
현재 스티커까지의 점수의 최댓값 = max(현재 스티커를 뜯는 경우, 현재 스티커를 뜯지 않는 경우)

현재 스티커를 뜯는 경우 = 대각선 왼쪽 스티커까지의 점수의 최댓값 + 현재 스티커의 점수
현재 스티커를 뜯지 않는 경우 = max(바로 왼쪽 스티커까지의 점수의 최댓값, 대각선 왼쪽 스티커까지의 점수의 최댓값)

종합하면 (현재 스티커까지의 점수의 최댓값) = max(대각선 왼쪽 스티커까지의 점수의 최댓값 + 현재 스티커의 점수, 바로 왼쪽 스티커까지의 점수의 최댓값, 대각선 왼쪽 스티커까지의 점수의 최댓값) 입니다.
여기서 (대각선 왼쪽 스티커까지의 점수의 최댓값 + 현재 스티커의 점수)이 (대각선 왼쪽 스티커까지의 점수의 최댓값)보다 클 것이 분명하므로 (대각선 왼쪽 스티커까지의 점수의 최댓값)는 생략해도 됩니다. 따라서

현재 스티커까지의 점수의 최댓값 = max(대각선 왼쪽 스티커까지의 점수의 최댓값 + 현재 스티커의 점수, 바로 왼쪽 스티커까지의 점수의 최댓값)
*/
#include <iostream>

using namespace std;

int main()
{
    int t, dp[100001][2] = {0}, amount[100001][2] = {0};

    cin>>t;
    for(int i=0; i<t; i++)
    {
        int n;
        cin>>n;
        for(int j=0; j<2; j++)
        {
            for(int k=1; k<=n; k++)
                cin>>amount[k][j];
        }
        
        for(int j=1; j<=n; j++)
        {
            dp[j][0] = max(dp[j-1][1]+amount[j][0], dp[j-1][0]);
            dp[j][1] = max(dp[j-1][0]+amount[j][1], dp[j-1][1]);
        }
        cout<<max(dp[n][0], dp[n][1])<<'\n';
    }

    return 0;
}